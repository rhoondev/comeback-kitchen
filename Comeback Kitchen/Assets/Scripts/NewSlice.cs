using UnityEngine;
using EzySlice;

public class NewSlice : MonoBehaviour
{



    
// Ctrl + f for these codes if errors occur
// Removal Code R1 - remove if an issue happens immediately after cutting (physics break or something / knife stops moving)
// Removal Code R1 - remove if an issue happens where pieces can not be cut since they are too small



    private const int sliceLayerNum = 10;
    
    
    // bottom of the blade (by handle)
    [SerializeField] private Transform startSlicePoint;

    // top of the blade (pointy end)
    [SerializeField] private Transform endSlicePoint;

    [SerializeField] private Transform sliceAngle;
    [SerializeField] private Transform sliceAngle2;

    [SerializeField] private LayerMask sliceableLayer;


    




    void FixedUpdate()
    {
        // For future, make list of all points that knife goes through in an object. If the knife stops touching object, 
        //  take last pair of points in that list and create a plane with the first pair of points in that object
        // Also make new variable (prevHit) which is true if hasHit was true and say if(prevHit == true and hasHit != true) 
        //  ->  make a plane (Transform) and use .position and .up on the transform to get the correct info (vector and position) for the slice function

        bool hasHit = Physics.Linecast(startSlicePoint.position, endSlicePoint.position, out RaycastHit hit, sliceableLayer);
        if(hasHit)
        {
            // Debug.Log("Hit a sliceable object!!!");
            GameObject target = hit.transform.gameObject;
            Slice(target);
        }
    }

    // This function cuts the object in 2 halfs (separated by the normal plane of a transform)
    public void Slice(GameObject target)
    {
        // Code R1
        //disable gravity and forces for the object doing the slicing so that weird physics doesn't happen
        this.gameObject.GetComponent<Rigidbody>().useGravity = false;
        this.gameObject.GetComponent<Rigidbody>().linearVelocity = Vector3.zero;
        this.gameObject.GetComponent<Rigidbody>().angularVelocity = Vector3.zero;


        // get the Vector of the knife's edge (angle from top of knife to blade, but at the end of the knife/point)
        Vector3 attackAngle = sliceAngle.position - endSlicePoint.position;

        // makes a vector which is the normal vector for a plane (perpendicular to plane)
        // subtracting 2 points (B - A) causes a Vector from A to B
        Vector3 planeNormal = Vector3.Cross(endSlicePoint.position - startSlicePoint.position, attackAngle - endSlicePoint.position);
        // normalize the vector

        planeNormal.Normalize();

        


        




        // ---- To make a plane in unity, you need the normal of the plane, followed by a point on that plane ----
        SlicedHull hull = target.Slice(endSlicePoint.position, planeNormal);


        if(hull != null)
        {

            // Cross section material is material that is put on cut face once cut happens
            Material crossSectionMaterial = target.GetComponent<Renderer>().material;

            GameObject upperHull = hull.CreateUpperHull(target, crossSectionMaterial);
            SetupSlicedComponent(upperHull);


            GameObject lowerHull = hull.CreateLowerHull(target, crossSectionMaterial);
            SetupSlicedComponent(lowerHull);

            // Code R2
            Destroy(target);       
        }





        
        // Code R1
        //make the object get it's gravity back and set the forces to zero so the object does not get the explosive force generated by the cut
        this.gameObject.GetComponent<Rigidbody>().useGravity = true;
        this.gameObject.GetComponent<Rigidbody>().linearVelocity = Vector3.zero;
        this.gameObject.GetComponent<Rigidbody>().angularVelocity = Vector3.zero;
    }

    public void SetupSlicedComponent(GameObject slicedObject)
    {
        // make sliced object have physics and stuff
        Rigidbody rb = slicedObject.AddComponent<Rigidbody>();
        // rb.useGravity = false;

        //make sliced object be able to interact with environment
        MeshCollider collider = slicedObject.AddComponent<MeshCollider>();
        // rb.useGravity = true;

        // make cut object cutable again
        slicedObject.layer = sliceLayerNum;

        // mesh colliders need to be convex when used with a rigidbody
        collider.convex = true;
        



        // add an initial force to each object
        rb.linearVelocity = Vector3.zero;
        rb.angularVelocity = Vector3.zero;
        rb.collisionDetectionMode = CollisionDetectionMode.Continuous;

        
        // rb.AddExplosionForce(cutForce, slicedObject.transform.position, 1);
    }













    private void OnDrawGizmos()
    {
        Gizmos.color = Color.red;

        // Draw lines between the 4 points in order
        Gizmos.DrawLine(startSlicePoint.position, endSlicePoint.position);
        Gizmos.DrawLine(endSlicePoint.position, sliceAngle.position);
        Gizmos.DrawLine(sliceAngle.position, sliceAngle2.position);
        Gizmos.DrawLine(sliceAngle2.position, startSlicePoint.position);
    }
}
